{{{?._abou}}}
lflab - lineral filter based audio lab
vX.YY
Copyright (C) Marton Laszlo Toth, 2014-2016.
This is free software (GNU General Public License version 2),
with ABSOLUTELY NO WARRANTY.
---
You can find the source code at:
https://github.com/marton-l-toth/lflab
---
The text of the license should be opened in a separate window.
In case it isn't see COPYING in the install directory or at
http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
---
Thanks to all g++,gdb,gtk,graphviz,gnuplot... developers, and
Steven W. Smith for his free DSP book (dspguide.com) 
==> getting started
{{{empty}}}
perhaps some day a description will be here
{{{?._strt}}}
lflab is free software with ABSOLUTELY NO WARRANTY:
==> about
A short overview of GUI elements, and of audio config:
==> etc.gui (general)
==> win.audio
The two windows already open:
==> win.main
==> win.tree
"!e" stands for "examples". The items 1,2,... are clipboards
double click (on the number not the arrow) to open them.
==> etc.!b and !e
==> win.clipboard
On the clipboards, left clk. plays (&stops when clicked again),
but each of these sounds is just a single representative of an
instrument which can be opened with right click for playing.
==> win.instrument(play)
There is help for most windows (a "?" button or in a menu "+").
The examples in "!e" are read-only but you can make copies
or create new objects. (Sounds/instruments can be quickly
copied with a middle-click (e.g. on the play grid), other
objects can only be created in the tree view window.
---
If you make new instruments/tracks/components, save them with
the "save" button. (or if you exit you can "autosave")
THERE IS NO UNDO, SAVE OFTEN!!!
==> etc.save files
{{{?._dtre}}}
Without any save files, you start with the "!b", "!c" subtree,
and (unless you started with the "-n" option) the "!e" subtree.
In "!b" you have the default clipboard "[]", help texts like
this one under "?", and various builtin boxes. You can open
a description for each builtin box by double-clicking them.
"!c" is reserved for contributions, see c/zB.c for details.
In "!e" the numbered items 1,2,... are clipboards (double-click
on the name(number) to open window), which contain instruments.
These instruments use builtin boxes and editable (to be exact,
copiable, then editable) boxes from "!e.box".
Example boxes are grouped as follows:
echo : combinations of simple echo filters
fb : simple examples for feedback
fe : string/membrane wrappers for the finite-elem builtin "=fe"
filt : some simple compound filters
hpar : combination (almost iteration) of parallel p/z filters
nz : noise-based boxes
osc : simple applications of non-linear (rev.quad.) oscillator
sel : some filter config using selector boxes
wave : waves modulated by other waves
{{{?._boxg}}}
A box is a little machine with 0...30 input ports and 1...30
output ports, each of which receives/sends 44100 real(64-bit)
numbers per second. From simple builtin boxes you can build
more complicated ones, and ultimately wrap them in an
instrument configuration to be able to conveniently select
their inputs and hear their outputs.
---
Most non-filter boxes can accept constant or variable input on
all input ports (except "phs" for waves "~xyz"), and most 
filters "=xyz" can take variable input only on the first input
port. Exceptions to this are mentioned in the description of
builtin boxes. "Not accepted" variable input does not result
in an explicit "error", only most of the input is ignored
(except the first sample, or in some cases the first sample
in each time-slice). On inputs labeled as "[xy]", lists are
==> etc.[lists]
expected, these are constant inputs unless noted otherwise.
---
Editable boxes can be graphs, calculators or tracks.
==> win.graph-box
==> win.calc-box
==> win.track
Browse "!b" and "!e" for primitive boxes and examples of
editable boxes.
==> etc.!b and !e
{{{?._nanl}}}
Some builtin boxes expect lists of small integers on some of
their input ports (e.g. [3 -4 -5 2]). The maximal list sizes
(x*y means at most x signed/unsigned y-bit integers) are:
1*32, 2*23, 3*16, 4*12, 5*9, 6*8, 7*7, 8*6, 9*5, 11*4 and 15*3
As a convention, such input ports are named like "[xy]".
---
As some readers familiar with floating-point arithmetic may
already have guessed, these lists are represented as NaN
(not-a-number) values. You cannot do arithmetic with these
values, and passing such list to input ports where a number
is expected also results in an error.
---
In future versions there may be boxes for handling such lists
(packing/unpacking/selecting/replacing values), but currently
the only way they can be used in instruments and graphs is to
pass them to builtin boxes without changing them.
---
Labels/strings like "this" can have at most 6 ASCII characters,
they are currently only used for slider group boxes. They are,
of course, also not numbers.
---
Known bug: when you input a list which is too long, the nice
behaviour would be to drop the last few elements (possibly with
a message in the "errors" window). Currently a "haircut" is
is applied instead: the highest bit(s) of each elements are
silently dropped.
{{{?._file}}}
THERE IS NO UNDO, SAVE OFTEN!!!
This help text describes file handling from the GUI file menu
(can be opened with the "+" menu button on the tree window). 
For the syntax of the command line, type "lflab -h" in a shell.
---
There are two kinds of save files: normal & library. The whole
object tree (except the read-only parts) can be saved to a
normal file ("save"/"save as"), to be loaded later ("load").
There is only one object tree: when you load multiple files the
object trees will be merged, and you can save them in one file.
(You get errors for name collisions; lots of them when you try
to load the same file twice.) You can return to "empty" state
with the "restart" commands from the main/file menus.
---
Unless turned off, autosaves are made at regular intervals. For
both autosaves and regular save files backups may be made.
Backup copies have "--1", "--2", ... endings for both autosave
and normal files. (e.g. when you save to "abc.lf", the previous
save will be moved to "abc--1.lf", the one before "abc--2.lf")
==> win.config -- here you can set autosave and backup options
The "load" window has a button "see autosaves" for convenient
recovering of autosaves. To make sure autosaves are not over-
written while you try to recover them, autosave is turned off
when in empty (black on grey titles) or recover (white on blue)
modes; when you save to (or load) a non-autosave file, autosave
is back to normal (as configured). If you issue an exit/restart
with autosave command in empty/recover mode, a special autosave
file "__asv--x.lf" will be created -- unlike other (auto)save
files, this file never has backup copies.)
==> etc.libraries -- how to create/load libraries (like ".!e")
THERE IS NO UNDO, SAVE OFTEN!!!
{{{?._lib}}}
A library is a collection of boxes and instruments which can be
used in multiple projects. Unless you start the program with
the "-n" command line optrion, the default "<instdir>/ex.lf"
examples library is automatically loaded, providing the ".!e"
subtree of read-only objects. 
---
Other libraries can be loaded with the "load lib" command (file
menu), but only in "empty" state (to strictly avoid references
from read-only to editable objects). Currently there is no
automatic mechanism for loading libary dependencies, so if your
(normal) save file refers (*) to objects in libraries (other
than the default one), you have to load the libs _before_ the
normal file (either with "load lib" or in the command line).
(*) Not all references are visible (see the source code for
details :) ) -- as a general rule when you have used a library
during creating your (normal) save file, you will probably also
need the same librari(es) for reloading it.
---
You can create a library with "save lib" (file menu). You can
save the left or right selected folder to the library file.
You have to be careful that the saved subtree should be self-
contained, i.e. not using objects outside the given folder.
(Known bug/weakness: this is not checked at "save lib", errors
only come when you try to load you new library.)
---
"load lib" can only load files created with "save lib".
On the other hand, you can load libraries with "load" as normal
files, and edit them before calling "save lib" again. Remember,
"save lib" saves only the selected folder: unless you _also_
make a normal save (to a different file), objects outside this
folder will be lost.
==> etc.save files
{{{?._wFlo}}}
Load file: this is a standard GTK file open window.
The only addition is the "see autosaves" button which switches
to the directory where the autosaves can be found.
---
When you load multiple files, the two object trees will be
merged; you might get errors from name collisions.
If you want to discard the current object tree (except for the
builtins and default (.!e) library), restart the program from
the main menu or the file (tree window) menu.
---
If you load an autosave file (without having any non-autosave
file already loaded), lflab will go to "recover mode" shown
by a white-on-blue "(recover)" instead of the filename -- until
you save with a new name or load a normal save file, autosave
will be turned off (to avoid overwriting the autosave file(s)
which you intend to recover).
==> etc.save files
{{{?._wFll}}}
Load library: this is a standard GTK file open window.
Here you can load libraries (like the default one ".!e"), which
were saved with the "save lib" command. The objects loaded from
the library will be read-only and will not be saved.
---
To avoid really interesting errors which would result from
read-only objects having references to editable ones, load lib
is only allowed when the object tree is "empty" (that is, has
only builtin and read-only objects).
---
Currently there is no automatic loading of needed libaries.
You have to either load them one-by-one using this window, or
list them on the command line (for the latter, you can set an
alias/shortcut).
---
The default library (normally in /usr/share/lflab/ex.lf) is
always loaded automatically unless lflab is started with the
"-n" command line option.
==> etc.libraries
==> win.fd.save lib
{{{?._wFsa}}}
Save as...: this is a standard GTK file save window.
Here you can save your project with a (different) file name.
(When your project has no filename yet, the "save" button in
the main window also opens this window.) It is recommended to
choose a file name which ends with ".lf", so that the file will
be shown in the "load" window using the default filter.
---
lflab will refuse to overwrite non-regular files (directories/
symlinks/sockets/...), files which do not seem to be lflab save
files, and autosave files (in the autosave dir.) -- even if you 
say "yes" to "are you sure?". (If not, you have found a bug!)
---
Currently saving is done in batch mode, which can result in
buffer overrun even for medium-size files. To avoid unpleasant
breaks, you should save only when no sound is being played.
(autosave, which can be configured in the main config (below),
works this way automatically.)
==> etc.save files
==> win.config
{{{?._wFsl}}}
Save lib: this is a standard GTK file save window.
Here you can create libraries -- collections of boxes
and instruments to be used from other projects (like the deault
library ".!e"). You can only save one (non-root) folder of the
object tree. This file can be later with "load lib", which will
load the objects as read-only; or as a normal save file with
"load", for further editing.
---
You can save the left or the right selected directory. (You can
select the folder you want to save in the tree window while the
file dialog is open -- lflab has no "modal" windows.)
==> etc.libraries
==> win.fd.load lib
{{{?._wFds}}}
Directory select: this is a standard GTK dir. select/create w.,
with an extra "default" button which -- as you might have
guessed -- restores the default value for the given directory
setting. Unless you save the config in the main config window
(or the audio config window, currently there is only one lf.ini
file), the setting will be effective only until you exit.
==> win.config
{{{?._wma}}}
This help text describes the main window. For general help, see
==> getting started
kussb+ - kill all sounds (not the same as mute, cf. below)
unplot - restart gnuplot (close all gnuplot windows)
LR - display tree window (on top)
++ - main menu (here you can open the console, show the
pole-zero diagram for the last filter, configure audio, write
timing log, and exit)
save - save file (name can be changed in the tree window)
rec - start/stop recording (see auconv link below)
CPU meter: green-OK, yellow-high load, red-danger grey-muted
CPU meter should run about 1 dashed line / sec, depending
on the speed setting.
(if stopped or very fast then something doesn't work...)
---
Mute mode: Ctrl+right-click on CPU meter (grey when muted)
In mute mode the audio device is closed, so other programs
can use it (but close them before "unmuting"), sounds/boxes
are not stopped, recording (if on) continues.
==> win.audio
==> win.tree
==> win.auconv
Note: main window is configured to be "always on top" whenever
the window manager permits it. This has a side effect: when you
open a small window (e.g. instrument/play and input windows),
it may "hide" behind the main window.
{{{?._puls}}}
Disclaimer: I have only tried with pulseaudio 2.0 using a
more-or-less default configuration. If you know better, please
dot not hesitate to tell me:
@@@
It seems that pulseaudio timing behaviour (at least when used
through the ALSA snd_pcm_ interface) depends on whether zero or
non-zero sample values are written to the PCM interface. This
completely breaks the clock adjustments in this program, so
please use a hardware device. (ALSA SW mixer works, although
with a longer latency than HW devices). 
---
LFLAB will open the HW device for exclusive use, but this
should not cause much trouble -- a simple ctrl+right-click on
the CPU meter, and the device is released. If pulseaudio is
in autospawn mode (default), and you have some PA app running
(like pavucontrol) PA will grab the device in a few seconds.
---
Because exclusive open only works when PA is not running, the
"kill PA" option is provided for convenience, which forcibly
stops PA on start/unmute, and hopefully grabs the device before
it starts again (so you don't have to turn autospawn off).
This only works when PA is configured in a per-user mode (which
is the default and recommended PA configuration). On most
systems "-9" is safe (immediate stop of process), but on some 
machines closing the device too abruptly can cause problems.
{{{?._wau}}}
If you are running LFLAB on this machine for the first time,
you should configure the audio because the default settings are
not likely to work, especially if you have PulseAudio:
==> etc.pulseaudio
The device name "default" typically means a SW mixer, and
HW mixers are called "hw:x" or "plughw:w", sometimes having
sub-devices. If your device name is not listed, you can also
edit the text field below -- the menu button (like for channel
config) is only for convenience.
---
Channel config: for most systems, "lr" works perfectly well,
but you might have more then two outputs ("s" means sum,
"a" is average, "c" is center (sqrt(2)*"a" = "s"/sqrt(2)), and
"z" is for zero). For example "rl" swaps outputs, and "lrc" can
be used if you have a subwoofer as 3rd output.
---
Speed is controlled by the first two sliders, buffer size is
2^(11-"spd"/20) frames, and the reserve buffer is "rsv" % of
this size. Larger speed and smaller reserve mean faster
response, but more risk of (very unpleasant) buffer underrun.
---
"try" and "t/w" say how many times the opening of the audio
device is attempted, and how many msecs. to wait in between.
In most cases clock mode can be left unchanged ("retBS").
---
"kill PA" means to forcibly stop pulseaudio (see link above).
You can restart the audio from this window, applying settings.
(roughly equivalent to ctrl+right-clicking the CPU meter twice)
There is only one config file, so "save" is the same as in:
==> win.config
{{{?._wcf}}}
This help text describes the main config window (available from
the "++" menu in the main window). For a list of command line
options, start the program with "lflab -l".
sv.exec - save files with exec right (line 1: #!/usr/bin/lflab)
min/asv - autosave every x minutes (*) (0: off)
au.tlog - automatically write timing log on GUI exit (max. 4MB)
{sv|as|tl}.bkup - max # of backup copies for save, a.sv. & tlog
dev - features under development (at your own risk :))
{wav-|atmp}dir - set WAV/FLAC or audio tmpfile. directory (**)
==> win.auconv -- details for writing to WAV/FLAC
ask/keep/wav/flac - default action when audio tmp file is ready
(the auconv window will appear only when set to "ask")
lim - max time (sec.) for automatic "write to WAV" commands
---
(*) to avoid unpleasant buffer underruns, autosave happens only
when no sound is being played, or in mute mode
(**) it is recommended to make a directory under you home dir.
for the WAV/FLAC files. Unless you are very short on RAM, you
should leave atmpdir on ramdisk (run/shm) -- on a real disk
(even SSD) it can cause performance problems/buffer underruns.
---
Directories shown for information: homedir is the default WAV/
FLAC target, logs and autosaves go to userdir, instdir is where
lflab is installed, and if the GUI and console are not enough
for you, you can send commands to the pipe "A" in workdir. :)
---
Finally, you can save settings to the file "<userdir>/lf.ini".
Since there is only one ini file (not counting the backups),
this button saves all config, just like the save button in:
==> win.audio
{{{?._wtr}}}
This help text describes the tree window. For general help, see
==> getting started
On the top, you can see the name of your file & the file menu:
==> etc.save files
Here you can browse and edit the object tree (the same tree is
visible on left & right views). For object selection (in other
windows) you have 3 menu buttons ("[" "*" "]"): the middle one
(with variable label) shows a shortlist of recently opened or
edited objects, and "["/"]" show the objects in the selected  
folder in the left/right tree view (in this window).
---
The object tree can contain the following types of objects:
folders (see below), intruments, boxes and clipboards.
==> win.instrument(cfg)
==> win.clipboard
==> etc.box (general)
A folder can contain up to 32 named objects (of any type).
Name: up to 20 ASCII characters except dot(.) and dollar sign.
(up to 20 ASCII characters except dot(.) and dollar sign)
Folders can be opened by double-clicking on the name or
clicking on the little +/arrow. (clipboards can also be opened
as folders (+/>) but in most cases it is more convenient to
open their own window (double-click)).
---
On the bottom, there are buttons for rename/local copy/
copy/move/del and a create object menu button. The text field
above the buttons is used for all these operations.
(for copy/move set the text on the "from" side). 
{{{?._gui}}}
Gui -- general description
Cyan (like "save" on main win.) -- simple button
Yellow (like "++" on main win.) -- menu button
Green number + grey label (like vol. on main win.) -- counter
On counters, left click increments, right clicks decrements.
For some counters, shift+click and ctrl+click incr/decr more.
(not all counters have an attached slider)
For most menu buttons left & right click have the same effect,
but for menus where the first item is in [brackets], left
click activates the first item, without opening the menu.
Text fields (like file name in top line of tree view window)
are standard text fields, with usual copy & paste functions.
---
When strange things happen, it can be helpful to open the
console (from main win./++ menu) because the information
there is much more detailed then in the "Errors" window.
{{{?._plan}}}
Planned features (please don't take these as promises :) )
- import of external audio
- improved track editor usability (drag & drop?)
- default values for boxes
- description for non-builtin boxes
- plot/save/record to backgr. job (like autovol calc.)
- RPM package
- more builtin boxes and example editable boxes
- support of various MIDI HW
==> etc.midi.new devices
{{{?._midd}}}
If you want support for your favourite MIDI input device,
please do as follows:
0. enable "dev" in main config to allow MIDI input, quit and
restart lflab (will hang when another program is using one of
your MIDI devices -- primarily this is why MIDI input is among 
the "under development, at you own risk" features)
1. open the console, type '?' and the (possibly precise) vendor
and type of your MIDI input device (lines starting with '?'
are echoed as "undefined command", and written to log)
2. type a '?' character, followed by a short description of
what are you going to do right now. (e.g. press and then
release the first 5/last 5 keys, turn knobs, move sliders etc.)
to avoid confusion, press enter before proceeding to 3. (again,
you should see your text echoed back as "undefined command".)
3. do as you have promised in 2. (with keys try hitting them
with different speeds, with knobs/sliders please reach both
endpoints, for touchpads all 4 corners etc.)
You should see messages starting with "midi_c". When you don't,
either the Linux kernel does not see your device, or you have
forgotten "dev" (see 0.)
4. unless you finished all keys/controls/pads/etc. go back to 2
5. flush log (or exit), and send me the lf.log file
@@@
{{{?._wwp}}}
Small button on the left, below (or between) the sliders:
left-click: focus (keyboard) on grid, right-click: menu
--- MOUSE ---
L: default action (set in config window, play in clik mode)
Sh-L: toggle (or play in tggl mode)
Ctrl-L: play unique (or play in uniq mode)
M: copy
Sh-M: copy to current track
R: set (config window is updated)
Sh-R: set but keep constants
Ctrl-R: kill
Release L: stop (hold mode) otherwise no effect
--- KEYS ---
If keys are configured, they are visible in the grid.
(unless the window is very small)
A key press (release) has the same effect as left click (rel.)
Use the ESC key to enter / leave key edit mode.
In key edit mode a purple box cursor is visible.
Left-click to select square, mid-click to delete key,
press (non-ESC) key to assign.
{{{?._wgr}}}
At a time you can have one selected input (blue), a selected
output (red) and a selected box (purple).
(external input counts as output, and vice versa)
Top toolbar: number of inputs, output, feedback (see below),
reserved (later, there will be a 'replace' mode), box select
(left/sl/right, see tree view for obj selection),
connect (sel. output to sel. input), set value (sel. input)
remove (selected box), and shuffle.
Every input has either a constant value (== button), or
is connected to an output (or external input) (---> button).
Shuffle does not work for all graphs (and sometimes it only
changes the serial nr. of boxes not the layout).
Because graph layout is calculated by an external program
(graphviz/dot, many thanks to its developers!), after every
new/deleted connection the graph is redrawn.
Feedback: The delay (!i) is expected to be a >0 constant.
The special output >i comes back to the special input <i
with !i delay. (when delay goes below 0.01 (10ms), CPU
usage will increase rapidly).
---
Because an external program is started, opening the first 
graph box window may cause an audio buffer underrun.
==> win.tree
{{{?._wit}}}
An iterated filter is a filter chain consisting of multiple
instances of the same "simple" filter.
In the current version, all instances of the filter have the
same parameters. The first input (in) is the input of the
first filter, #b is the number of filter boxes, all the other
inputs are "inherited" from the simple filter.
#b is expected to be constant, it is rounded and limited to
the interval [0...1024].
If #b rounds to zero or the simple filter is undefined, the
result is an empty filter which copies its input (in) to the 
output unchanged. CPU cost is only a little more than #b times
the cost of the simple filter.
---
Currently the only modifiable parameter is the simple filter.
This box has no configurable GUI -- the colors and the in/out
labels (except for "in" and "#b") are inherited from the simple
filter.
{{{?._wcc}}}
Calculator boxes are stateless boxes (each set of outputs only
depends on the current set of inputs, not previous ones),
defined by arithmetic expressions. A calc-box can have 0...30
inputs, 0..30 temporary variables and 1...30 outputs.
Temporary variables can be calculated using the inputs and
previous temporary variables. Output values can be calculated 
using inputs, temporaries and previous outputs.
---
In the top line you can set the number of inputs/tmps/outputs.
There is a line for each temporary/output: as you edit the
expression, the status (right) follows; a white-on-green "+"
means OK, while white-on-red means error:
"(" - syntax error 
"x" - non-existing input
"y"/"z" - non-existing or out-of-order tmp/output
"f" - non-existing function
"<" - too few arguments to function
">" - too many arguments to function
---
Currently only operators +,-,*,/,^(power) and the conditional
if<(a,b,c,d) (if a<b then c else d) are supported.
{{{?._wtk}}}
right now, the track editor is very simple, so the recommended
way is to write individual sounds (or perhaps simple loops) to
.wav files, and use a more full-featured tracker to compose
your 4-hour opera :)
---
Top line: prev/snd menu/next, turn align (to vertical lines)
on/off, move selected sound, start/stop playing & recording,
set default divide & pixel/beat. Under p/b, from the "clip"
button you can drag a sound from the current (p.src) clipboard.
On the left column, divide per line can be set, the arrows are
for scrolling. On the top and bottom (beat #) lines you can
click for context menus (play/loop some # of beats).
---
Every track can be used as a box (in graphs or instruments),
with BPM and from-to-repeat as input (BPM can be non-constant).
If you set a negative number "-x" for BPM, the BPM of the
containing track will be multiplied by x. (so -1.0 means simply
equal to parent track BPM, useful for track-in-track.)
---
keyboard:
x - cut & select next
X or backspace - cut & select previous
0...9 and a...v - select sound from curr. paste src. clipboard
(that sound can be dragged out of the top right "clip" button)
{{{?._wwcg}}}
This help text describes the top part (above "vol/envlp/LR") of
the instrument config window. In the top left corner, you can
set the play mode (clik/hold/tggl/uniq), described here:
==> win.instrument(play)
"stp" stops, "kill" stops sounds without "down" section
clicking on the 6-char-icon plays the selected sound
Right-click on the mini-grid opens the play window, left-click
is the same as a left-click on the grid in the play window.
---
You can display the output using gnuplot (many thanks to its
developers!) in a specified time interval, and also the
frequency spectrum (FFT) in a time interval and freq. range.
---
The four labels below the plot parameters select the config
line below them: [#] is grid dimensions config, "tlim" is time
limit (affects only sounds in a track, in beats not seconds,
-1 means no limit, auto filled from record-to-track)
==> win.icfg.autovol -- "a.v" tab (auto volume adjust)
==> win.auconv -- "wav" tab (write to WAV)
Note: changing grid dimensions can change the selected sound
(known bug: left col. in scl.grps. is not updated in this case)
{{{?._wwav}}}
When using source/filter pairs with a wide range of inputs,
the output volume can vary greatly. The automatic volume
calibration makes convenient playback of such configurations
possible. The volume is computed on a (per default) 9x9x9x9
hypercube grid, and interpolated (on log.scale) on positions
between. The four dimensions are x, y (grid) and the first
two sliders. Per default, s5 is L/R and s6 is (manual, mul. by
autovol) volume, so if you use s3 and s4 you should only
configure inputs for them which do not significantly alter the
output volume. "t" is time in seconds, "r" is repeat (for boxes
involving noise, currently buggy so leave it 1).
The button "calc" starts the calculation. (right-clk stops).
The calculation goes left-to-right, so (assuming x=9) when it 
reaches 11.2%, the first column is already playable.
(known bug: sometimes the progress bar is stuck at 99.x%, but
it is only a GUI error, the calculation is actually finishes)
{{{?._wwc}}}
An instrument/sound is a wrapper object which makes boxes
playable. You can give constant (DC) inputs to a source box and
an optional filter box. These inputs can be either fixed or
selectable from a (linear/logarithmic/quadratic etc.) interval
using grid click x and y coordinates and some (max.6) sliders.
In addition to the box inputs, you can set duration, simple
enveloping, volume, and L/R balance.
---
This object is called "instrument/sound" because from every
single sound the whole instr. config can be edited, and every
instrument config has a specific "selected" sound (marked by
an "X" on the play grid, and specified by the first column of
the scale groups.)
---
As you may have noticed, this window is somewhat complicated,
so the description is broken to several parts:
==> win.icfg.general(top)
==> win.icfg.autovol
==> win.icfg.scale lines
==> win.icfg.scale groups
{{{?._wwsg}}}
Open/close scale groups with the "<>" / "><" buttons (right)
---volume/envlp(grp 1)---
"/*" and "\*" menu buttons set the shape of the "up" and "down"
sections of the enveloping function (for the source box):
(L)inear, (Q)uadratic, (E)xponential, (G)aussian, (S)igmoid, 
(-)None (up only), (A)utomatic (down only). Their length 
(except for "A") is given by "up" and "dn/l" in seconds.
The down section starts after "wait" seconds. (counted from the
start, not the end of "up" -- so if "wait"<"up" then the two
sections overlap and are multiplied). 
Auto mode "A": the src box ends when output is under the limit
"dn/l" for "wait" seconds. Filters are always in auto mode,
ending when under "Flim" for "Fwt" seconds.
Volume is vol1*vol2 (in most cases vol2 is fixed at 1.0)
LR: left-right balance (-1:left 0:center 1:right)
HINT1: with small up/wait/down values you can create simple
impulses (with src=!b.misc.copy) or "contaminated" impulses
(with src=!e.box.nz.nz01) of various shapes.
HINT2: you can easily visualise enveloping functions with
gnuplot (source box:"!b.misc.copy", x=1, filter:none) --
the copy box outputs constant 1, so you only see the evp.func.
---src/filter (grp 2/3)---
You can select source/filter box from the object tree with the
3 menu buttons ([, S/F and ]), as described here (bottom of pg)
==> win.tree
The values are the inputs of the source and filter boxes.
The first (0th) input of the filter box is not configurable,
since it is connected to the output of the source box.
{{{?._wwsl}}}
In every scale line, there are 3 entry fields (for numbers),
and 3 menu buttons.
The first field is for constant value -- if the scale (see
below) is set to "con" it is always effective, otherwise it
is ignored on (grid) left click and overwritten on right clk.
The 2 other fields (sep. by "...") are the from-to values.
The first menu button select the source (x,y grid coord. or
one of the sliders; ignored when scale is "con" or "cn1").
The second one sets the scale: linear, logarithmic, quadratic,
cubic, harmonic (1/x), reverse quad. and reverse cubic.
"con" means that the first col. is never changed, "cn1" means
that the value is the "from" value (ignoring "to" and source)
---
With the last button you can set one value (typically a freq.)
as reference value "=", and can multiply "*" or divide "/"
other values (typically frqs and impulse lengths) by it.
(If you want more complicated relations between inputs, create
a graph box with builtin arithmetic or calculator boxes.)
{{{?._wcl}}}
A clipboard is a container for at most 32 instrument objects.
Besides providing a convenient collection, it also serves as a
source/target for copy/paste operations. 
"cp" - toggle copy target (*)
"ps" - toggle paste source (*)
"2x" - allow to create duplicated with copy
"au" - play when left-clicked (to select)
"xc" - exchange on right-click
"re" - redraw
"+"  - menu (you can delete objects here)
(*) at any time, there is one source clipboard and one target
clipboard; at start both are set to the default clipb. "!b.[]",
---
left-cl:sel, right-cl:open(play) ctrl+right-cl:open(cfg)
middle-click: copy
keybindings for instruments also work from this window
(first selected obj, then sel. row, then next row etc.)
{{{?._wacv}}}
This program has two ways to write sound data to audio files:
- "rec" (main window)  starts/ends a (stereo) recording
(unless tmp dir. is a ramdisk, this can cause serious slowdown)
- "wav" tab / "write" in instrument config window: here you can
select mono/stereo and from-to/full duration (from-to means the
interval given for plot(t) (top right)).
---
Audio files are first written to a 20-bit temporary file (.a20)
This window provides a shortcut to convert the file to WAV or
FLAC (if flac is installed), or delete it. The audio convert
window only appears when the configured action is "ask".
==> win.config -- here you can set default action & directories
">>wav" and ">>flac" convert the whole file, and delete the a20
file when successful (or when it is all zeroes). Alternatively
you can keep the a20 file, delete it or convert a portion of it
(the skip(from) and length are is seconds, fractions with dec.
points accepted, default is "0" for skip and "all to the end"
for len.) There is also a shortcut to the config window, where
you can set ">>wav", ">>flac" or "keep" as default action.
---
If you choose "keep", you can convert the files later using
the "lf.acv" program (start without arguments to see help).
Remember, /run/shm/ is a ramdisk, it will not survive a reboot.
---
If you want to listen to your new WAV/FLAC file with an audio
player, and you are using a harware audio device (which is btw.
strongly recommended), you can still do that without exiting:
ctrl+right-click on the CPU meter (main win.) to enable mute
mode (which releases the audio device), and ctrl+rclick on it
again (when the external player is finished) to enable sound.
{{{?._werr}}}
With the controls on the top, you can clear the list, set the
number of messages, turn "annoying" (raising the message window
on new error, but at most once per second) on and off, and
opening the console.
---
The console has much more detailed information than the error
message window, take a look when strange things are happening.
Everything that is printed on the console can also be found
in the <homedir>/.lflab/lf.log file. (if you want to see all
logs without exiting, choose "flush log" from main menu)
---
As a general rule, if you can read English at a strong
intermediate level, do have some experience as a computer user,
and still do not understand an error message, it is probably my
fault :)
==> reporting bugs
{{{?._rbug}}}
Please send the following:
- precise instructions how to reproduce the error
- a save file with which the error is reproducible
- log (lf.log in <your_homedir>/.lflab)
- lf.tlog (run "write tlog" from main menu)
- type of your sound card
- core file if any (see file /proc/sys/kernel/core_pattern,
if it looks like a file name pattern you can easily find the
core file, if not then you have some automatic core-file
collecting system, see its documentation to find the core)
---
If the program seems to be stuck in an infinite loop (CPU meter
not moving, but CPU is used), try SIGABRT to produce a core.
---
Not all of the above are absolutely necessary (and of course
not always applicable, e.g. when you found a typo in a help
text, no core or log files are needed), but the more you send,
the more chance you have to see the bug fixed.
@@@
