0win 0etc 1wr 2midi 1fd
{{{0.about}}}
lflab - lineral filter based audio lab
vX.YY
Copyright (C) Marton Laszlo Toth, 2014-2016.
This is free software (GNU General Public License version 2),
with ABSOLUTELY NO WARRANTY.
---
You can find the source code at:
https://github.com/marton-l-toth/lflab
---
The text of the license should be opened in a separate window.
In case it isn't see COPYING in the install directory or at
http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
---
Thanks to all g++,gdb,gtk,graphviz,gnuplot... developers, and
Steven W. Smith for his free DSP book (dspguide.com) 
==> 0.getting started
{{{0.getting started}}}
lflab is free software with ABSOLUTELY NO WARRANTY:
==> 0.about
If you are running lflab for the first time, you probably have
to configure the audio output:
==> 1.audio
You can check if audio is working by opening one of the example
clipboards, and click on the icons (various colors, 2x3 chars)
==> .!e.6 -- left-click:play right-click: open instrument
==> 1.wrap/play -- the window opened by right-click
Most windows either have a "?" button, or a "+" menubutton with
a "help" command. If you are new to lflab, it is recommended to
read the following general help texts:
==> 0.gui/general -- overview of GUI elements
==> 2.object tree -- general overview
==> 2.wrap -- sound/instrument objects
==> 2.direct wrap -- config instr. using boxes
==> 2.shadow wrap -- config instr. using another wrap
==> 2.box -- basic building blocks of sounds
==> 2.!b and !e -- overview of builtins and examples
==> 1.auconv -- how to write to wav/flac
==> 1.config -- some settings you might change
==> 2.save files -- THERE IS NO UNDO, SAVE OFTEN!!!
{{{2.!b and !e}}}
Without any save files, you start with the "!b", "!c" subtree,
and (unless you started with the "-n" option) the "!e" subtree.
In "!b" you have the default clipboard "[]", help texts like
this one under "?", and various builtin boxes. You can open
a description for each builtin box by double-clicking them.
"!c" is reserved for contributions, see c/zB.cc for details.
In "!e" the numbered items 1,2,... are clipboards (double-click
on the name(number) to open window), which contain instruments.
These instruments use builtin boxes and editable (to be exact,
copiable, then editable) boxes from "!e.box".
Example boxes are grouped as follows:
echo : combinations of simple echo filters
fb : simple examples for feedback
fe : string/membrane wrappers for the finite-elem builtin "=fe"
filt : some simple compound filters
hpar : combination (almost iteration) of parallel p/z filters
imp : impulses
iter : iterated filters
nz : noise-based boxes
osc : simple applications of non-linear (rev.quad.) oscillator
sel : some filter config using selector boxes
trk : tracks
wave : waves modulated by other waves
---
the "sc" folder contains examples for "soundcloud.com/lflab".
in each (numbered) subdir, "T" is the main track
{{{2.object tree}}}
The object tree can be browsed in the "LR" window (the left and
right views are the same tree).
==> 1.tree -- create new objects, open/copy/move/...
==> 2.save files -- saving/reloading the objects you created
The object tree can contain the following kinds of objects:
- Folder: contains at most 32 of any kind of named objects
- Clipboard: contains at most 32 unnamed (0..9,a..v) wraps
- Box: a machine with 0...30 input and 1...30 output ports
- Wrap: playable sound/instrument object, a front-end for boxes
---
Tracks are of a somewhat mixed category: they are fully usable
as boxes (but also directly playable), and also a collection of
wrap objects.
==> 2.!b and !e -- builtin and example objects
==> 2.box
==> 2.wrap
==> 1.clipboard
{{{2.LTI filters}}}
LTI (linear & time-invariant) filters are defined as follows:
- When you multiply the input by a constant (amplify), the
output will also be multiplied by the same constant
- When you add (mix) the filtered output of two inputs, the
output is the same as for filtering the sum of two inputs
- When you delay the input, the output will be delayed by the
same amount (otherwise unchanged).
---
Builtin and example filters (names beginning with "=") are LTI
filters (some of them can have variable parameters -- these
filters are only time-invariant when all parameters (2nd, 3rd
etc. inputs) are constant.)
---
When you chain LTI filters, or sum their outputs with constant
weights, you get LTI filters as a result.
---
In wrap (instrument) config, as "filter box" an LTI filter is
expected -- this allows sharing a filter between multiple
source boxes. (when you give a non-LTI filter as filter, volume
setting and/or mixing will not work as expected -- if you want
to use non-LTI filters, build a graph box connecting the source
to the filter.
==> 1.graph-box
{{{2.wrap}}}
In lflab, the basic building blocks are boxes:
==> 2.box -- machine with 0..30 input and 1..30 output ports
Because most boxes need input on their input ports and all have
undefined duration, they are not directly playable (except for
tracks). Wraps provide a generic interface for boxes, where the
sound is selected via (at most) 8 controls (grid column/row + 6
sliders). Wraps have the following two windows:
==> 1.wrap/play -- play/set/quick copy
==> 1.wrap/config -- configure instrument, plot, ==>wav
There are no separate "instrument" and "sound" objects in the
object tree -- if you configure an instrument once, individual
sounds (e.g. in a track) will be copies of this object (with
different control positions), and the instrument configuration 
will be reachable/editable from each individual sound.
---
It is possible to create wraps as named objects in folders,
but generally it is more convenient to use clipboards. Wraps
are also the building blocks for tracks. In clipboards and
tracks wraps are represented by as small icon (also visible in
the wrap/config window): the top 2 letters (and bg/fg colour)
come from the (src/filter) boxes used, the other 4 letters show
the x,y,s1,s2 control positions.
---
There are two kinds of wraps:
==> 2.direct wrap -- maps the 8 controls to constant inputs for
a source box, an (optional) filter box, and general parameters
(volume/duration/left-right balance etc.)
==> 2.shadow wrap -- maps the 8 controls to controls of another
wrap (useful for track editing, by changing a single "reference
wrap" you can shift a melody or change the instrument without
editing every single sound).
{{{2.direct wrap}}}
When a direct wrap is played, a source box is started with
constant (DC) inputs on all input ports. If there is no filter
box, the output(s) are played/plotted/written(wav) directly.
If there is a filter box (which must have exactly one output
and at least one input port), the source box output is fed to
the first (0th) input of the filter box, and the filter box
output is played.
---
Currently there is no output configuration: source boxes with
at least 2 output are assumed to be stereo with the first two
outputs as left and right channel.
---
The filter box is assumed be linear and time independent.
==> 2.LTI filters
When using filters (especially complicated ones) the output
volume can vary greatly. For the first 4 controls (x,y,s1,s2)
this can be compensated automatically. By default, s5 is for
L/R and s6 is for volume, so it is recommended to use s3/s4 for
inputs which do not significantly affect output volume.
==> 3.autovol -- GUI for autovol config
There are two ways for defining duration of a box: you either
specify up/hold/down time or (when the box itself goes silent
after a while) stop the box after a (specified, default 0.5sec)
long "silence" (specified, default: output below 1/100000).
(for filters, only the latter option is available).
---
All the source/filter input values (except first filter input
which comes from the source box) and volume/duration/left-right
parameters can either be constant or an interval mapping from
one of the 8 controls (col.,row,6 sliders).
==> 1.wrap/config -- wrap config GUI
{{{2.shadow wrap}}}
When a shadow wrap is played, the control positions are mapped
to controls of a different wrap object ("target"). The target
wrap may also be a shadow wrap, but to make an actual sound,
you need a direct wrap at the end of the chain. (circular
references are not allowed.)
---
For each control, you have the following options:
- keep control position of target wrap
- pass a real number in [0..1] interval
- pass an integer
---
You may also set a (weighted) sum of two controls. The most
simple usage is swapping two controls (e.g. y<->s1) without
having to recalculate the autovol table. Shadow wraps also make
it easy to define a set of keys (*) once, and use it for many
different instruments. 
(*) currently only (PC) keyboard is supported -- for later
versions, MIDI HW support is also planned.
==> 1.wrap/config -- wrap config GUI
Shadow wraps make track editing much easier: in the following
examples, the tracks differ in only one wrap (the muted
"reference wrap" in line 04):
==> .!e.5 -- wraps 8,9,A,B (use tracks below)
==> .!e.box.trk.boci.1 -- make a copy and experiment
==> .!e.box.trk.boci.2 -- ref. wrap control changed
==> .!e.box.trk.boci.3 -- ref. wrap target changed
{{{2.box}}}
A box is a little machine with 0...30 input ports and 1...30
output ports, each of which receives/sends 44100 real(64-bit)
numbers per second. Boxes can be builtin boxes or user-defined
boxes. Click the following links for details:
==> 2.!b and !e -- builtin and example user-def. boxes
(if you want to code your own builtin box, see s/c/zB.cc)
==> 1.graph-box -- directed acyclic graph of other boxes
==> 1.iterated box -- the same box chained multiple times
==> 1.calc-box -- stateless calculator box
==> 1.track -- collection of (timed) wrap objects
Since most boxes have inputs on which they need values, and all
boxes have undefined duration, they cannot be played directly.
(Exc.: tracks have play/loop button/menu for convenience.)
Wrap (sound/instrument) objects provide a generic interface to
make playable (and recordable) sounds from boxes.
==> 2.wrap
Each input of a box can be constant or variable over time.
Some boxes do not accept variable inputs on some ports: this
means that all but the first sample (or, for some boxes, all
but the first sample in each (about 10ms) segment) of the
variable input will be ignored.
---
Box/port naming conventions (in !b and !e) :
Most non-filter boxes can accept constant or variable input on
all input ports (except "phs" for waves "~xyz"), and most 
filters "=xyz" can take variable input only on the first input
port. Exceptions to this are mentioned in the description of
builtin boxes. On inputs labeled as "[xy]", lists are
==> 2.[lists]
expected, these are constant inputs unless noted otherwise.
{{{2.[lists]}}}
Some builtin boxes expect lists of small integers on some of
their input ports (e.g. [3 -4 -5 2]). The maximal list sizes
(x*y means at most x signed/unsigned y-bit integers) are:
1*32, 2*23, 3*16, 4*12, 5*9, 6*8, 7*7, 8*6, 9*5, 11*4 and 15*3
As a convention, such input ports are named like "[xy]".
---
As some readers familiar with floating-point arithmetic may
already have guessed, these lists are represented as NaN
(not-a-number) values. You cannot do arithmetic with these
values, and passing such list to input ports where a number
is expected also results in an error.
---
In future versions there may be boxes for handling such lists
(packing/unpacking/selecting/replacing values), but currently
the only way they can be used in instruments and graphs is to
pass them to builtin boxes without changing them.
---
Labels/strings like "this" can have at most 6 ASCII characters,
they are currently only used for slider group boxes. They are,
of course, also not numbers.
---
Known bug: when you input a list which is too long, the nice
behaviour would be to drop the last few elements (possibly with
a message in the "errors" window). Currently a "haircut" is
is applied instead: the highest bit(s) of each elements are
silently dropped.
{{{2.save files}}}
THERE IS NO UNDO, SAVE OFTEN!!!
This help text describes file handling from the GUI file menu
(can be opened with the "+" menu button on the tree window). 
For the syntax of the command line, type "lflab -h" in a shell.
---
There are two kinds of save files: normal & library. The whole
object tree (except the read-only parts) can be saved to a
normal file ("save"/"save as"), to be loaded later ("load").
There is only one object tree: when you load multiple files the
object trees will be merged, and you can save them in one file.
(You get errors for name collisions; lots of them when you try
to load the same file twice.) You can return to "empty" state
with the "restart" commands from the main/file menus.
==> 5.load file
==> 5.save as
Unless turned off, autosaves are made at regular intervals. For
both autosaves and regular save files backups may be made.
Backup copies have "--1", "--2", ... endings for both autosave
and normal files. (e.g. when you save to "abc.lf", the previous
save will be moved to "abc--1.lf", the one before "abc--2.lf")
==> 1.config -- here you can set autosave and backup options
The "load" window has a button "see autosaves" for convenient
recovering of autosaves. To make sure autosaves are not over-
written while you try to recover them, autosave is turned off
when in empty (black on grey titles) or recover (white on blue)
modes; when you save to (or load) a non-autosave file, autosave
is back to normal (as configured). If you issue an exit/restart
with autosave command in empty/recover mode, a special autosave
file "__asv--x.lf" will be created -- unlike other (auto)save
files, this file never has backup copies.)
==> 2.libraries -- how to create/load libraries (like ".!e")
THERE IS NO UNDO, SAVE OFTEN!!!
{{{2.libraries}}}
A library is a collection of boxes and instruments which can be
used in multiple projects. Unless you start the program with
the "-n" command line optrion, the default "<instdir>/ex.lf"
examples library is automatically loaded, providing the ".!e"
subtree of read-only objects. 
---
Other libraries can be loaded with the "load lib" command (file
menu), but only in "empty" state (to strictly avoid references
from read-only to editable objects). Currently there is no
automatic mechanism for loading libary dependencies, so if your
(normal) save file refers (*) to objects in libraries (other
than the default one), you have to load the libs _before_ the
normal file (either with "load lib" or in the command line).
(*) Not all references are visible (see the source code for
details :) ) -- as a general rule when you have used a library
during creating your (normal) save file, you will probably also
need the same librari(es) for reloading it.
---
You can create a library with "save lib" (file menu). You can
save the left or right selected folder to the library file.
You have to be careful that the saved subtree should be self-
contained, i.e. not using objects outside the given folder.
(Known bug/weakness: this is not checked at "save lib", errors
only come when you try to load you new library.)
---
"load lib" can only load files created with "save lib".
On the other hand, you can load libraries with "load" as normal
files, and edit them before calling "save lib" again. Remember,
"save lib" saves only the selected folder: unless you _also_
make a normal save (to a different file), objects outside this
folder will be lost.
==> 2.save files
{{{5.load file}}}
Load file: this is a standard GTK file open window.
The only addition is the "see autosaves" button which switches
to the directory where the autosaves can be found.
---
When you load multiple files, the two object trees will be
merged; you might get errors from name collisions.
If you want to discard the current object tree (except for the
builtins and default (.!e) library), restart the program from
the main menu or the file (tree window) menu.
---
If you load an autosave file (without having any non-autosave
file already loaded), lflab will go to "recover mode" shown
by a white-on-blue "(recover)" instead of the filename -- until
you save with a new name or load a normal save file, autosave
will be turned off (to avoid overwriting the autosave file(s)
which you intend to recover).
==> 2.save files
{{{5.load lib}}}
Load library: this is a standard GTK file open window.
Here you can load libraries (like the default one ".!e"), which
were saved with the "save lib" command. The objects loaded from
the library will be read-only and will not be saved.
---
To avoid really interesting errors which would result from
read-only objects having references to editable ones, load lib
is only allowed when the object tree is "empty" (that is, has
only builtin and read-only objects).
---
Currently there is no automatic loading of needed libaries.
You have to either load them one-by-one using this window, or
list them on the command line (for the latter, you can set an
alias/shortcut).
---
The default library (normally in /usr/share/lflab/ex.lf) is
always loaded automatically unless lflab is started with the
"-n" command line option.
==> 2.libraries
==> 5.save lib
{{{5.save as}}}
Save as...: this is a standard GTK file save window.
Here you can save your project with a (different) file name.
(When your project has no filename yet, the "save" button in
the main window also opens this window.) If the filter is on
("lflab saves") a ".lf" ending will automatically be appended.
---
lflab will refuse to overwrite non-regular files (directories/
symlinks/sockets/...), files which do not seem to be lflab save
files, and autosave files (in the autosave dir.) -- even if you 
say "yes" to "are you sure?". (If not, you have found a bug!)
---
Currently saving is done in batch mode, which can result in
buffer overrun even for medium-size files. To avoid unpleasant
breaks, you should save only when no sound is being played.
(autosave, which can be configured in the main config (below),
works this way automatically.)
==> 2.save files
==> 1.config
{{{5.save lib}}}
Save lib: this is a standard GTK file save window.
Here you can create libraries -- collections of boxes
and instruments to be used from other projects (like the deault
library ".!e"). You can only save one (non-root) folder of the
object tree. This file can be later with "load lib", which will
load the objects as read-only; or as a normal save file with
"load", for further editing.
---
You can save the left or the right selected directory. (You can
select the folder you want to save in the tree window while the
file dialog is open -- lflab has no "modal" windows.)
==> 2.libraries
==> 5.load lib
{{{5.select dir}}}
Directory select: this is a standard GTK dir. select/create w.,
with an extra "default" button which -- as you might have
guessed -- restores the default value for the given directory
setting. Unless you save the config in the main config window
(or the audio config window, currently there is only one lf.ini
file), the setting will be effective only until you exit.
==> 1.config
{{{1.main}}}
This help text describes the main window (title "lf").
==> 0.getting started -- click here for general help
kussb+ - kill all sounds (not the same as mute, cf. below)
unplot - restart gnuplot (close all gnuplot windows)
LR - display tree window (on top)
++ - main menu (here you can open the console, show the
pole-zero diagram for the last filter, configure audio, write
timing log, and exit)
CPU meter: green-OK, yellow-high load, red-danger grey-muted
CPU meter should run about 1 dashed line / sec, depending
on the speed setting.
(if stopped or very fast then something doesn't work...)
save - save file ("save as" is in the file menu in tree window)
rec - start/stop recording (see auconv link below)
==> 1.tree
==> 1.auconv
Mute mode: Ctrl+right-click on CPU meter (grey when muted)
In mute mode the audio device is closed, so other programs
can use it (but close them before "unmuting"), sounds/boxes
are not stopped, recording (if on) continues.
==> 1.audio
Note: main window is configured to be "always on top" whenever
the window manager permits it. This has a side effect: when you
open a small window (e.g. wrap/play and input windows), it may 
"hide" behind the main window.
{{{2.pulseaudio}}}
Disclaimer: I have only tried with pulseaudio 2.0 using a
more-or-less default configuration. If you know better, please
dot not hesitate to tell me:
@@@
It seems that pulseaudio timing behaviour (at least when used
through the ALSA snd_pcm_ interface) depends on whether zero or
non-zero sample values are written to the PCM interface. This
completely breaks the clock adjustments in this program, so
please use a hardware device. (ALSA SW mixer works, although
with a longer latency than HW devices). 
---
LFLAB will open the HW device for exclusive use, but this
should not cause much trouble -- a simple ctrl+right-click on
the CPU meter, and the device is released. If pulseaudio is
in autospawn mode (default), and you have some PA app running
(like pavucontrol) PA will grab the device in a few seconds.
---
Because exclusive open only works when PA is not running, the
"kill PA" option is provided for convenience, which forcibly
stops PA on start/unmute, and hopefully grabs the device before
it starts again (so you don't have to turn autospawn off).
This only works when PA is configured in a per-user mode (which
is the default and recommended PA configuration). On most
systems "-9" is safe (immediate stop of process), but on some 
machines closing the device too abruptly can cause problems.
{{{1.audio}}}
If you are running LFLAB on this machine for the first time,
you should configure the audio because the default settings are
not likely to work, especially if you have PulseAudio:
==> 2.pulseaudio
The device name "default" typically means a SW mixer, and
HW mixers are called "hw:x" or "plughw:w", sometimes having
sub-devices. If your device name is not listed, you can also
edit the text field below -- the menu button (like for channel
config) is only for convenience.
---
Channel config: for most systems, "lr" works perfectly well,
but you might have more then two outputs ("s" means sum,
"a" is average, "c" is center (sqrt(2)*"a" = "s"/sqrt(2)), and
"z" is for zero). For example "rl" swaps outputs, and "lrc" can
be used if you have a subwoofer as 3rd output.
---
Speed is controlled by the first two sliders, buffer size is
2^(11-"spd"/20) frames, and the reserve buffer is "rsv" % of
this size. Larger speed and smaller reserve mean faster
response, but more risk of (very unpleasant) buffer underrun.
---
"try" and "t/w" say how many times the opening of the audio
device is attempted, and how many msecs. to wait in between.
In most cases clock mode can be left unchanged ("retBS").
---
"kill PA" means to forcibly stop pulseaudio (see link above).
You can restart the audio from this window, applying settings.
(roughly equivalent to ctrl+right-clicking the CPU meter twice)
There is only one config file, so "save" is the same as in:
==> 1.config
{{{1.config}}}
This help text describes the main config window (available from
the "++" menu in the main window). For a list of command line
options, start the program with "lflab -h".
sv.exec - save files with exec right (line 1: #!/usr/bin/lflab)
min/asv - autosave every x minutes (*) (0: off)
au.tlog - automatically write timing log on GUI exit (max. 4MB)
{sv|as|tl}.bkup - max # of backup copies for save, a.sv. & tlog
xterm - terminal emulator (for console & GPL text)
autocon - automatically open console when debug info is written
dev - features under development (at your own risk :))
{wav-|atmp}dir - set WAV/FLAC or audio tmp.file directory (**)
ask/keep/wav/flac - default action when audio tmp file is ready
==> 1.auconv -- details for writing to WAV/FLAC
(*) to avoid unpleasant buffer underruns, autosave happens only
when no sound is being played, or in mute mode
(**) it is recommended to make a directory under you home dir.
for the WAV/FLAC files. Unless you are very short on RAM,
atmpdir should be on a ramdisk: on a real disk (even SSD) it
can cause performance problems/buffer underruns. (default is
/run/shm if it exists, otherwise /tmp)
---
Directories shown for information: homedir is the default WAV/
FLAC target, logs and autosaves go to userdir, instdir is where
lflab is installed, and if the GUI and console are not enough
for you, you can send commands to the pipe "A" in workdir. :)
---
Finally, you can save settings to the file "<userdir>/lf.ini".
Since there is only one ini file (not counting the backups),
this button saves all config, just like the save button in:
==> 1.audio
{{{1.tree}}}
This help text describes the tree window (title "LR").
==> getting started -- click here for general help
==> 2.object tree -- general description of object tree
On the top, you can see the name of your file & the file menu:
==> 2.save files
Here you can browse and edit the object tree (the same tree is
visible on left & right views). For object selection (in other
windows) you have 3 menu buttons ("[" "*" "]"): the middle one
(with variable label) shows a shortlist of recently opened or
edited objects, and "["/"]" show the objects in the left/right
selected folder here.
---
The object tree can contain the following types of objects:
folders (see below), intruments, boxes and clipboards.
==> 2.wrap -- sound/instrument
==> 1.clipboard -- collection of wraps
==> 2.box -- machines, building blocks of sounds
A folder can contain up to 32 named objects (of any type).
Name: up to 20 ASCII characters except dot(.) and dollar sign.
Folders can be opened by double-clicking on the name or
clicking on the little +/arrow. (clipboards can also be opened
as folders (+/>) but in most cases it is more convenient to
open their own window (double-click)).
---
On the bottom, there are buttons for rename/local copy/
copy/move/del and a create object menu button. The text field
above the buttons is used for all these operations.
(for copy/move set the text on the "from" side). 
{{{0.gui/general}}}
Gui -- general description
Cyan (like "save" on main win.) -- simple button
Yellow (like "++" on main win.) -- menu button
Green number + grey label (like vol. on main win.) -- counter
---
On counters, left click increments, right clicks decrements.
For some counters, shift+click and ctrl+click incr/decr more.
(not all counters have an attached slider)
---
For most menu buttons left & right click have the same effect,
but for menus where the first item is in [brackets], left
click activates the first item, without opening the menu.
---
Text fields (like the two text fields at the bottom of the tree
window, above the buttons) are standard text fields, with usual
copy & paste functions.
---
When strange things happen, it can be helpful to open the
console (from main win./++ menu) because the information
there is much more detailed then in the "Errors" window.
{{{0.planned features}}}
Planned features (please don't take these as promises :) )
- import of external audio
- improved track editor usability (block edit?)
- default values for boxes
- description for non-builtin boxes
- plot/save/record to backgr. job (like autovol calc.)
- more builtin boxes and example editable boxes
- auto-tune for finite-element filters
- support of various MIDI HW
==> 4.new devices
{{{4.new devices}}}
If you want support for your favourite MIDI input device,
please do as follows:
0. enable "dev" in main config to allow MIDI input, quit and
restart lflab (will hang when another program is using one of
your MIDI devices -- primarily this is why MIDI input is among 
the "under development, at you own risk" features)
1. open the console, type '?' and the (possibly precise) vendor
and type of your MIDI input device (lines starting with '?'
are echoed as "undefined command", and written to log)
2. type a '?' character, followed by a short description of
what are you going to do right now. (e.g. press and then
release the first 5/last 5 keys, turn knobs, move sliders etc.)
to avoid confusion, press enter before proceeding to 3. (again,
you should see your text echoed back as "undefined command".)
3. do as you have promised in 2. (with keys try hitting them
with different speeds, with knobs/sliders please reach both
endpoints, for touchpads all 4 corners etc.)
You should see messages starting with "midi_c". When you don't,
either the Linux kernel does not see your device, or you have
forgotten "dev" (see 0.)
4. unless you finished all keys/controls/pads/etc. go back to 2
5. flush log (or exit), and send me the lf.log file (you can
find it in the ".lflab" directory under your home directory)
@@@
{{{1.box-gui}}}
Here you can configure the input/output labels and FG/BG colors
for graph and calculator boxes. (iterated boxes "inherit" these
properties by the simple box used.)
---
These labels and colors are visible in wraps and graphs using
the box. Change of labels has immediate effect, colors only
change when you click the "OK" button.
---
Unlike for number of inputs/outputs box GUI config does not
cause redrawing of every affected object. (you can manually
redraw boxes/wraps by clicking on the "internal" title.
{{{1.wrap/play}}}
In this window you can play and quick-copy sounds/instruments.
==> 2.wrap -- general description
==> 1.wrap/config -- configure instrument
Small button on the left, below (or between) the sliders:
left-click: focus (keyboard) on grid, right-click: menu
--- MOUSE ---
L: default action (set in config window, play in clik mode)
Sh-L: toggle (or play in tggl mode)
Ctrl-L: play unique (or play in uniq mode)
M: copy
Sh-M: copy to current track
R: set (config window is updated)
Sh-R: set but keep constants
Ctrl-R: kill
Release L: stop (hold mode) otherwise no effect
--- KEYS ---
If keys are configured, they are visible in the grid.
(unless the window is very small)
A key press (release) has the same effect as left click (rel.)
Use the ESC key to enter / leave key edit mode.
In key edit mode a purple box cursor is visible.
Left-click to select square, mid-click to delete key,
press (non-ESC) key to assign.
{{{1.wrap/config}}}
This help text describes the instrument config window. For a
general description of how wrap objects work in lflab, see:
==> 2.wrap
For playing the instrument, open the play window by right-
clicking on the mini-grid (top center):
==> 1.wrap/play
You can also play a sound by left-clicking the mini-grid (but
the sliders are only available in the play window), or clicking
the sound icon (left to the mini-grid).
---
The following links describe parts of the window, from top to
bottom ( (D) : direct wrap only, (S) : shadow wrap only )
==> 3.play/plot -- clik/hold/..., icon, mini-grid, plot(t/F)
Tab select: [#], wav, cfg... (selects contents of line below)
==> 3.grid config -- "[#]" tab
==> 3.write to file -- "wav" tab
==> 3.general config -- "cfg" tab
==> 3.autovol -- "a.v" tab (D)
==> 3.shadow cfg -- "sic" tab (S)
Line groups: (open/close with "<>"/"><" button on the right)
==> 3.volume/envp -- (D)
==> 3.source/filter -- (D)
==> 3.scale lines -- (D)
==> 3.target -- (S)
{{{1.primitive box}}}
Primitive boxes has no configurable properties, therefore their
only GUI window is a description. They cannot be copied, moved
or deleted. From the '+' menu (top right), the "info1" command
can be useful, because you will get a "used by" list (on the
console) which makes finding examples easier.
---
You can find primitive boxes in the ".!b" subtree.
---
If you want to implement primitive boxes yourself, please see
s/c/zB.cc for some examples with explanation. These boxes will
be placed in the ".!c" (contrib) subtree.
{{{1.graph-box}}}
A graph box is a compound box made from other boxes by
connecting their inputs/outputs. Every input (*) is either set
to a constant value (set sel. input with "==" button) connected
to an output (conn. sel.input & sel.output with "--->" button).
(*) viewed from inside the box, external output counts here as
"input" and external output as "input".
---
At a time you can have one selected input (blue), a selected
output (red) and a selected box (purple).
Top toolbar: number of inputs, output, feedback (see below),
replace mode (when lit), box select (insert/replace selected),
==> 1.tree -- see how "[" "sl" "]" menubuttons work
connect, set value, remove ("X") and graph menu ("++"):
- [shuffle] (reorder boxes, not always possible)
- rgb:sel sets graph FG/BG colors to selected box
- inlbl:sel sets input labels using conn. to selected box
- inlbl:all sets input labels using conn. to all boxes
(menu opens for right-click, left-clk shuffles)
==> 1.box-gui -- set colors and in/out labels manually
Because graph layout is calculated by an external program
(graphviz/dot, many thanks to its developers!), after every
new/deleted connection the graph is redrawn. Drawing the first
graph may cause delay/buffer underrun.
---
Feedback: The delay (!i) is expected to be a >0 constant.
The special output >i comes back to the special input <i
with !i delay. (when delay goes below 0.01 (10ms), CPU
usage will increase rapidly).
==> win.tree
{{{1.iterated box}}}
An iterated box is a compound box consinsting of multiple
instances of the same "simple" box, chained (the first input
of the (i+1)th box is connected to the (only) output of the
(i)th box. This arrangement is specifically fitting for filter
chains (when the simple box is a linear filter, the iter. box
will also be one), but the simple box can be set (from L/R sel.
folder or shortlist) to any box with at least one input and
exactly one output. The first input is used for chaining, the
last input (**) may vary on a specified scale, all other inputs
are shared between all instances of the simple box. 
---
The iterated filter inherits all inputs from the simple filter
(except the last one, when a scale is specified). Extra inputs:
(#b): number of instances. (rounded, const expected) (*)
(z0): last input value for first instance (const exp.)
(z1): last input value for last instance (const exp.)
(z*): last input multiplier: (z1) = (z0)*(z*) (const exp.)
(z%): scale as in map01, -3...3 (const exp., when scale="ask")
==> .!b.map.map01
(#b) is always present, (z0) when scale is not "con", "z1=z0zr"
switches between (z1) and (z*)
---
(*) if (#b) is zero or "simple box" is undefined, the iter. box
simply copies the (first) input to the output.
(**) if you want an other parameter (or multiple ones) to be
varied, wrap the filter in a simple graph box.
---
CPU cost is only a little more than (#b) times the cost of the
simple filter. (#b) is limited to 1024.
{{{1.calc-box}}}
Calculator boxes are stateless boxes (each set of outputs only
depends on the current set of inputs, not previous ones),
defined by arithmetic expressions. A calc-box can have 0...30
inputs, 0..30 temporary variables and 1...30 outputs.
Temporary variables can be calculated using the inputs and
previous temporary variables. Output values can be calculated 
using inputs, temporaries and previous outputs.
---
In the top line you can set the number of inputs/tmps/outputs.
There is a line for each temporary/output: as you edit the
expression, the status (right) follows; a white-on-green "+"
means OK, while white-on-red means error:
"(" - syntax error 
"x" - non-existing input
"y"/"z" - non-existing or out-of-order tmp/output
"f" - non-existing function
"<" - too few arguments to function
">" - too many arguments to function
---
Currently only operators +,-,*,/,^(power) and the conditional
if<(a,b,c,d) (if a<b then c else d) are supported.
You can change the in/out labels (and FG/BG color) here:
==> 1.box-gui
However, in the expressions the inputs/outputs will still be
called "x0", "x1", ... "x<n>" and "y0", "y1" ... "y<n>".
{{{1.track}}}
right now, the track editor is very simple, so the recommended
way is to write individual sounds (or perhaps simple loops) to
.wav files, and use a more full-featured tracker to compose
your 4-hour opera :)
---
Top line: prev/snd menu/next, turn align (to vertical lines)
on/off, move selected sound, start/stop playing & recording,
set default divide & pixel/beat. Under p/b, from the "clip"
button you can drag a sound from the current (p.src) clipboard.
On the left column, divide per line can be set, the arrows are
for scrolling. On the top and bottom (beat #) lines you can
click for context menus (play/loop some # of beats).
---
Every track can be used as a box (in graphs or instruments),
with BPM and from-to-repeat as input (BPM can be non-constant).
If you set a negative number "-x" for BPM, the BPM of the
containing track will be multiplied by x. (so -1.0 means simply
equal to parent track BPM, useful for track-in-track.)
---
keyboard:
x - cut & select next
X or backspace - cut & select previous
0...9 and a...v - select sound from curr. paste src. clipboard
(that sound can be dragged out of the top right "clip" button)
---
You can find examples in ".!e.box.trk" and ".!e.sc".
{{{3.play/plot}}}
This help text describes the top part (above "vol/envlp/LR") of
the instrument config window. In the top left corner, you can
set the play mode (clik/hold/tggl/uniq), described here:
==> 1.wrap/play
"stp" stops, "kill" stops sounds without "down" section
clicking on the 6-char-icon plays the selected sound
Right-click on the mini-grid opens the play window, left-click
is the same as a left-click on the grid in the play window.
---
You can display the output using gnuplot (many thanks to its
developers!) in a specified time interval, and also the
frequency spectrum (FFT) in a time interval and freq. range.
---
The four labels below the plot parameters select the config
line below them: [#] is grid dimensions config, "tlim" is time
limit (affects only sounds in a track, in beats not seconds,
-1 means no limit, auto filled from record-to-track)
==> 3.autovol -- "a.v" tab (auto volume adjust)
==> win.auconv -- "wav" tab (write to WAV)
Note: changing grid dimensions can change the selected sound
(known bug: left col. in scl.grps. is not updated in this case)
{{{3.autovol}}}
"a.v" tab in the (direct) wrap config window
When using source/filter pairs with a wide range of inputs,
the output volume can vary greatly. The automatic volume
calibration makes convenient playback of such configurations
possible. The volume is computed on a (per default) 9x9x9x9
hypercube grid, and interpolated (on log.scale) on positions
between. The four dimensions are x, y (grid) and the first
two sliders. Per default, s5 is L/R and s6 is (manual, mul. by
autovol) volume, so if you use s3 and s4 you should only
configure inputs for them which do not significantly alter the
output volume. "t" is time in seconds, "r" is repeat (for boxes
involving noise, currently buggy so leave it 1).
The button "calc" starts the calculation. (right-clk stops).
The calculation goes left-to-right, so (assuming x=9) when it 
reaches 11.2%, the first column is already playable.
(known bug: sometimes the progress bar is stuck at 99.x%, but
it is only a GUI error, the calculation is actually finishes)
{{{3.shadow cfg}}}
"sic" tab in the (shadow) wrap config window
Currently there are two toggle buttons here:
iadj.S/iadj.T mean source/target side integer adjustment.
For controls in real interval mode (leftmost label "off"),
these are ignored; they only matter for integer mode.
---
When iadj.T is on, the control positions of the target wrap
are added to the passed (integer) values.
When iadj.S is on, the control positions of the used controls
in the source (the shadow wrap in which you enable iadj.S) are
added to the passed integers. This is only recommended to wraps
which are used indirectly (TODO: example), because for direct
use this means multiplying the control values by 2.
==> 3.target -- how to change/configure target wrap
{{{3.volume/envp}}}
Open/close scale groups with the "<>" / "><" buttons (right)
The first scale group is for configuring volume, left-right
and enveloping function.
---
"/*" and "\*" menu buttons set the shape of the "up" and "down"
sections of the enveloping function (for the source box):
(L)inear, (Q)uadratic, (E)xponential, (G)aussian, (S)igmoid, 
(-)None (up only), (A)utomatic (down only). Their length 
(except for "A") is given by "up" and "dn/l" in seconds.
The down section starts after "wait" seconds. (counted from the
start, not the end of "up" -- so if "wait"<"up" then the two
sections overlap and are multiplied).
---
Auto mode "A": the src box ends when output is under the limit
"dn/l" for "wait" seconds. Filters are always in auto mode,
ending when output vol. is under "Flim" for "Fwt" seconds.
Volume is vol1*vol2 (in most cases vol2 is fixed at 1.0)
LR: left-right balance (-1:left 0:center 1:right)
==> 3.scale lines -- set controls -> values mapping
HINT1: with small up/wait/down values you can create simple
impulses (with src=!b.misc.copy) or "contaminated" impulses
(with src=!e.box.nz.nz01) of various shapes.
HINT2: you can easily visualise enveloping functions with
gnuplot (source box:"!b.misc.copy", x=1, filter:none) --
the copy box outputs constant 1, so you only see the evp.func.
{{{3.source/filter}}}
Open/close scale groups with the "<>" / "><" buttons (right)
The second and third scale group is for configuring the source
and the filter box. A filter box must have at least one input,
and exactly one output, and should be an LTI filter.
==> 2.LTI filters
To change the source/filter box, you have to select a box (or
at least the containing folder) in the tree window, then you
can select the box from the "[" or "]" menu. In the middle menu
("S" or "F") you find a shortlist of recently opened objects.
==> 1.tree -- here you can select objects
If you select another wrap object from the menu, the whole
source or filter scale group will be copied from that wrap obj.
---
The values in the source/filter group are the (constant/DC)
inputs for the source and filter boxes.
The first input of the filter box is not configurable,
since it is connected to the output of the source box.
==> 3.scale lines -- set controls -> values mapping
{{{3.scale lines}}}
Open/close scale groups with the "<>" / "><" buttons (right)
In every scale line, there are 3 entry fields (for numbers),
and 3 menu buttons.
The first field is for constant value -- if the scale (see
below) is set to "con" it is always effective, otherwise it
is ignored on (grid) left click and overwritten on right clk.
The 2 other fields (sep. by "...") are the from-to values.
The first menu button select the source (x,y grid coord. or
one of the sliders; ignored when scale is "con" or "cn1").
The second one sets the scale: linear, logarithmic, quadratic,
cubic, harmonic (1/x), reverse quad. and reverse cubic.
"con" means that the first col. is never changed, "cn1" means
that the value is the "from" value (ignoring "to" and source)
---
With the last button you can set one value (typically a freq.)
as reference value "=", and can multiply "*" or divide "/"
other values (typically frqs and impulse lengths) by it.
(If you want more complicated relations between inputs, create
a graph box with builtin arithmetic or calculator boxes.)
'A' means multiply by autovol (default setting for vol0)
==> 3.autovol
{{{3.target}}}
Here you can select the target wrap for a shadow wrap. As with
other object selections, you have left&right selected (in tree
window) directory: "[" and "]", and shortlist: "T". (The target
may also be a shadow wrap, but in order to hear a sound, you
need a direct wrap at the end of the chain.)
---
With "<>"/"><" you can open/close the target config.
In the first line, you can select which controls of the target
you want to configure at all. (for unconfigured controls, the
current value of the target box will be taken.)
---
For each configured line, you have the following options:
Label (left): "on" means integer mode (useful for freq./notes),
"off" means real (0..1 interval)
2nd column: constant value (computed or hand-configured, like
1st col for direct wraps)
Counter (=x): adjustment (mult. by 0.01 in interval mode)
Menu-number pairs: you can set the target control to be the
sum of (at most) 2 weighted source side controls.
TODO: examples
==> 3.shadow cfg -- extra options
{{{3.grid config}}}
"[#]" tab in the wrap config window
Here you can set the number of columns(x) and rows(y) of the
grid, and the resolution of the sliders (1,2,...6). You can
also set the coloring of the grid (a:b means that every b-th
line is red instead of grey, and every a-th red line is changed
to yellow. For "x" you also have the option of piano-style
shading ("C"..."H").
Note: When you change the resolution (and the control position
is fixed), the sound may change.
{{{3.write to file}}}
"wav" tab in the wrap config window.
Here you can write the sound to a wav/flac file.
"stereo" -- toggle 2-channel output
"from-to" -- only write the selected (plot(t), top right) part
"write" -- click this to write to file
For details how audio file output works, see these help texts:
==> 1.auconv -- this will pops up, unless ...
==> 1.config -- ... you set a default action here
{{{3.general config}}}
"cfg" tab in the wrap config window
Here you can change the following settings for a wrap:
- mute: when on, the wrap is silent in a track
- t: time limit (beats, not in sec., useful for tracks)
- >shdw: middle-click creates a shadow wrap instead of a copy
- sl.upd: slider pos. updated when slider moving (when off,
update only happens at right-click).
---
Mute is useful for "reference" shadow wraps in tracks.
"t" is automatically set by "record-to-track"
{{{1.clipboard}}}
A clipboard is a container for at most 32 instrument objects.
Besides providing a convenient collection, it also serves as a
source/target for copy/paste operations. 
"cp" - toggle copy target (*)
"ps" - toggle paste source (*)
"2x" - allow to create duplicated with copy
"au" - play when left-clicked (to select)
"xc" - exchange on right-click
"re" - redraw
"+"  - menu (you can delete objects here)
(*) at any time, there is one source clipboard and one target
clipboard; at start both are set to the default clipb. "!b.[]",
---
left-cl:sel, right-cl:open(play) ctrl+right-cl:open(cfg)
middle-click: copy
keybindings for instruments also work from this window
(first selected obj, then sel. row, then next row etc.)
{{{1.auconv}}}
This program has two ways to write sound data to audio files:
- "rec" (main window)  starts/ends a (stereo) recording
(unless tmp dir. is a ramdisk, this can cause serious slowdown)
- "wav" tab / "write" in instrument config window: here you can
select mono/stereo and from-to/full duration (from-to means the
interval given for plot(t) (top right)).
---
Audio files are first written to a 20-bit temporary file (.a20)
This window provides a shortcut to convert the file to WAV or
FLAC (if flac is installed), or delete it. The audio convert
window only appears when the configured action is "ask".
==> win.config -- here you can set default action & directories
">>wav" and ">>flac" convert the whole file, and delete the a20
file when successful (or when it is all zeroes). Alternatively
you can keep the a20 file, delete it or convert a portion of it
(the skip(from) and length are is seconds, fractions with dec.
points accepted, default is "0" for skip and "all to the end"
for len.) There is also a shortcut to the config window, where
you can set ">>wav", ">>flac" or "keep" as default action.
---
If you choose "keep", you can convert the files later using
the "lf.acv" program (start without arguments to see help).
Remember, /run/shm/ is a ramdisk, it will not survive a reboot.
---
If you want to listen to your new WAV/FLAC file with an audio
player, and you are using a harware audio device (which is btw.
strongly recommended), you can still do that without exiting:
ctrl+right-click on the CPU meter (main win.) to enable mute
mode (which releases the audio device), and ctrl+rclick on it
again (when the external player is finished) to enable sound.
{{{1.error list}}}
With the controls on the top, you can clear the list, set the
number of messages, turn "annoying" (raising the message window
on new error, but at most once per second) on and off, and
opening the console.
---
The console has much more detailed information than the error
message window, take a look when strange things are happening.
Everything that is printed on the console can also be found
in the <homedir>/.lflab/lf.log file. (if you want to see all
logs without exiting, choose "flush log" from main menu)
---
As a general rule, if you can read English at a strong
intermediate level, do have some experience as a computer user,
and still do not understand an error message, it is probably my
fault :)
==> 0.reporting bugs
{{{0.reporting bugs}}}
Please send the following:
- precise instructions how to reproduce the error
- a save file with which the error is reproducible
- log (lf.log in <your_homedir>/.lflab)
- lf.tlog (run "write tlog" from main menu)
- type of your sound card
- core file if any (see file /proc/sys/kernel/core_pattern,
if it looks like a file name pattern you can easily find the
core file, if not then you have some automatic core-file
collecting system, see its documentation to find the core)
---
If the program seems to be stuck in an infinite loop (CPU meter
not moving, but CPU is used), try SIGABRT to produce a core.
---
Not all of the above are absolutely necessary (and of course
not always applicable, e.g. when you found a typo in a help
text, no core or log files are needed), but the more you send,
the more chance you have to see the bug fixed.
@@@
